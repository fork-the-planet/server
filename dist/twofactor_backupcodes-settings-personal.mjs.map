{"version":3,"file":"twofactor_backupcodes-settings-personal.mjs","sources":["../node_modules/pinia/dist/pinia.mjs","../build/frontend/apps/twofactor_backupcodes/src/service/logger.ts","../build/frontend/apps/twofactor_backupcodes/src/service/PrintService.ts","../build/frontend/apps/twofactor_backupcodes/src/service/BackupCodesService.ts","../build/frontend/apps/twofactor_backupcodes/src/store/index.ts","../build/frontend/apps/twofactor_backupcodes/src/views/PersonalSettings.vue","../build/frontend/apps/twofactor_backupcodes/src/settings-personal.ts"],"sourcesContent":["/*!\n * pinia v3.0.3\n * (c) 2025 Eduardo San Martin Morote\n * @license MIT\n */\nimport { hasInjectionContext, inject, toRaw, watch, unref, markRaw, effectScope, ref, isRef, isReactive, getCurrentScope, onScopeDispose, getCurrentInstance, reactive, toRef, nextTick, computed, toRefs } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\n/**\n * setActivePinia must be called to handle SSR at the top of functions like\n * `fetch`, `setup`, `serverPrefetch` and others\n */\nlet activePinia;\n/**\n * Sets or unsets the active pinia. Used in SSR and internally when calling\n * actions and getters\n *\n * @param pinia - Pinia instance\n */\n// @ts-expect-error: cannot constrain the type of the return\nconst setActivePinia = (pinia) => (activePinia = pinia);\n/**\n * Get the currently active pinia if there is any.\n */\nconst getActivePinia = () => (hasInjectionContext() && inject(piniaSymbol)) || activePinia;\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\no) {\n    return (o &&\n        typeof o === 'object' &&\n        Object.prototype.toString.call(o) === '[object Object]' &&\n        typeof o.toJSON !== 'function');\n}\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\n// TODO: can we change these to numbers?\n/**\n * Possible types for SubscriptionCallback\n */\nvar MutationType;\n(function (MutationType) {\n    /**\n     * Direct mutation of the state:\n     *\n     * - `store.name = 'new name'`\n     * - `store.$state.name = 'new name'`\n     * - `store.list.push('new item')`\n     */\n    MutationType[\"direct\"] = \"direct\";\n    /**\n     * Mutated the state with `$patch` and an object\n     *\n     * - `store.$patch({ name: 'newName' })`\n     */\n    MutationType[\"patchObject\"] = \"patch object\";\n    /**\n     * Mutated the state with `$patch` and a function\n     *\n     * - `store.$patch(state => state.name = 'newName')`\n     */\n    MutationType[\"patchFunction\"] = \"patch function\";\n    // maybe reset? for $state = {} and $reset\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\n\n/*\n * FileSaver.js A saveAs() FileSaver implementation.\n *\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\n * Morote.\n *\n * License : MIT\n */\n// The one and only way of getting global scope in all environments\n// https://stackoverflow.com/q/3277182/1008999\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\n    ? window\n    : typeof self === 'object' && self.self === self\n        ? self\n        : typeof global === 'object' && global.global === global\n            ? global\n            : typeof globalThis === 'object'\n                ? globalThis\n                : { HTMLElement: null })();\nfunction bom(blob, { autoBom = false } = {}) {\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\n    if (autoBom &&\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\n    }\n    return blob;\n}\nfunction download(url, name, opts) {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', url);\n    xhr.responseType = 'blob';\n    xhr.onload = function () {\n        saveAs(xhr.response, name, opts);\n    };\n    xhr.onerror = function () {\n        console.error('could not download file');\n    };\n    xhr.send();\n}\nfunction corsEnabled(url) {\n    const xhr = new XMLHttpRequest();\n    // use sync to avoid popup blocker\n    xhr.open('HEAD', url, false);\n    try {\n        xhr.send();\n    }\n    catch (e) { }\n    return xhr.status >= 200 && xhr.status <= 299;\n}\n// `a.click()` doesn't work for all browsers (#465)\nfunction click(node) {\n    try {\n        node.dispatchEvent(new MouseEvent('click'));\n    }\n    catch (e) {\n        const evt = new MouseEvent('click', {\n            bubbles: true,\n            cancelable: true,\n            view: window,\n            detail: 0,\n            screenX: 80,\n            screenY: 20,\n            clientX: 80,\n            clientY: 20,\n            ctrlKey: false,\n            altKey: false,\n            shiftKey: false,\n            metaKey: false,\n            button: 0,\n            relatedTarget: null,\n        });\n        node.dispatchEvent(evt);\n    }\n}\nconst _navigator = typeof navigator === 'object' ? navigator : { userAgent: '' };\n// Detect WebView inside a native macOS app by ruling out all browsers\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\n    /AppleWebKit/.test(_navigator.userAgent) &&\n    !/Safari/.test(_navigator.userAgent))();\nconst saveAs = !IS_CLIENT\n    ? () => { } // noop\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView or mini program\n        typeof HTMLAnchorElement !== 'undefined' &&\n            'download' in HTMLAnchorElement.prototype &&\n            !isMacOSWebView\n            ? downloadSaveAs\n            : // Use msSaveOrOpenBlob as a second approach\n                'msSaveOrOpenBlob' in _navigator\n                    ? msSaveAs\n                    : // Fallback to using FileReader and a popup\n                        fileSaverSaveAs;\nfunction downloadSaveAs(blob, name = 'download', opts) {\n    const a = document.createElement('a');\n    a.download = name;\n    a.rel = 'noopener'; // tabnabbing\n    // TODO: detect chrome extensions & packaged apps\n    // a.target = '_blank'\n    if (typeof blob === 'string') {\n        // Support regular links\n        a.href = blob;\n        if (a.origin !== location.origin) {\n            if (corsEnabled(a.href)) {\n                download(blob, name, opts);\n            }\n            else {\n                a.target = '_blank';\n                click(a);\n            }\n        }\n        else {\n            click(a);\n        }\n    }\n    else {\n        // Support blobs\n        a.href = URL.createObjectURL(blob);\n        setTimeout(function () {\n            URL.revokeObjectURL(a.href);\n        }, 4e4); // 40s\n        setTimeout(function () {\n            click(a);\n        }, 0);\n    }\n}\nfunction msSaveAs(blob, name = 'download', opts) {\n    if (typeof blob === 'string') {\n        if (corsEnabled(blob)) {\n            download(blob, name, opts);\n        }\n        else {\n            const a = document.createElement('a');\n            a.href = blob;\n            a.target = '_blank';\n            setTimeout(function () {\n                click(a);\n            });\n        }\n    }\n    else {\n        // @ts-ignore: works on windows\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\n    }\n}\nfunction fileSaverSaveAs(blob, name, opts, popup) {\n    // Open a popup immediately do go around popup blocker\n    // Mostly only available on user interaction and the fileReader is async so...\n    popup = popup || open('', '_blank');\n    if (popup) {\n        popup.document.title = popup.document.body.innerText = 'downloading...';\n    }\n    if (typeof blob === 'string')\n        return download(blob, name, opts);\n    const force = blob.type === 'application/octet-stream';\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\n        typeof FileReader !== 'undefined') {\n        // Safari doesn't allow downloading of blob URLs\n        const reader = new FileReader();\n        reader.onloadend = function () {\n            let url = reader.result;\n            if (typeof url !== 'string') {\n                popup = null;\n                throw new Error('Wrong reader.result type');\n            }\n            url = isChromeIOS\n                ? url\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\n            if (popup) {\n                popup.location.href = url;\n            }\n            else {\n                location.assign(url);\n            }\n            popup = null; // reverse-tabnabbing #460\n        };\n        reader.readAsDataURL(blob);\n    }\n    else {\n        const url = URL.createObjectURL(blob);\n        if (popup)\n            popup.location.assign(url);\n        else\n            location.href = url;\n        popup = null; // reverse-tabnabbing #460\n        setTimeout(function () {\n            URL.revokeObjectURL(url);\n        }, 4e4); // 40s\n    }\n}\n\n/**\n * Shows a toast or console.log\n *\n * @param message - message to log\n * @param type - different color of the tooltip\n */\nfunction toastMessage(message, type) {\n    const piniaMessage = 'üçç ' + message;\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\n        // No longer available :(\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\n    }\n    else if (type === 'error') {\n        console.error(piniaMessage);\n    }\n    else if (type === 'warn') {\n        console.warn(piniaMessage);\n    }\n    else {\n        console.log(piniaMessage);\n    }\n}\nfunction isPinia(o) {\n    return '_a' in o && 'install' in o;\n}\n\n/**\n * This file contain devtools actions, they are not Pinia actions.\n */\n// ---\nfunction checkClipboardAccess() {\n    if (!('clipboard' in navigator)) {\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\n        return true;\n    }\n}\nfunction checkNotFocusedError(error) {\n    if (error instanceof Error &&\n        error.message.toLowerCase().includes('document is not focused')) {\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\n        return true;\n    }\n    return false;\n}\nasync function actionGlobalCopyState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\n        toastMessage('Global state copied to clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalPasteState(pinia) {\n    if (checkClipboardAccess())\n        return;\n    try {\n        loadStoresState(pinia, JSON.parse(await navigator.clipboard.readText()));\n        toastMessage('Global state pasted from clipboard.');\n    }\n    catch (error) {\n        if (checkNotFocusedError(error))\n            return;\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nasync function actionGlobalSaveState(pinia) {\n    try {\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\n            type: 'text/plain;charset=utf-8',\n        }), 'pinia-state.json');\n    }\n    catch (error) {\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nlet fileInput;\nfunction getFileOpener() {\n    if (!fileInput) {\n        fileInput = document.createElement('input');\n        fileInput.type = 'file';\n        fileInput.accept = '.json';\n    }\n    function openFile() {\n        return new Promise((resolve, reject) => {\n            fileInput.onchange = async () => {\n                const files = fileInput.files;\n                if (!files)\n                    return resolve(null);\n                const file = files.item(0);\n                if (!file)\n                    return resolve(null);\n                return resolve({ text: await file.text(), file });\n            };\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\n            fileInput.oncancel = () => resolve(null);\n            fileInput.onerror = reject;\n            fileInput.click();\n        });\n    }\n    return openFile;\n}\nasync function actionGlobalOpenStateFile(pinia) {\n    try {\n        const open = getFileOpener();\n        const result = await open();\n        if (!result)\n            return;\n        const { text, file } = result;\n        loadStoresState(pinia, JSON.parse(text));\n        toastMessage(`Global state imported from \"${file.name}\".`);\n    }\n    catch (error) {\n        toastMessage(`Failed to import the state from JSON. Check the console for more details.`, 'error');\n        console.error(error);\n    }\n}\nfunction loadStoresState(pinia, state) {\n    for (const key in state) {\n        const storeState = pinia.state.value[key];\n        // store is already instantiated, patch it\n        if (storeState) {\n            Object.assign(storeState, state[key]);\n        }\n        else {\n            // store is not instantiated, set the initial state\n            pinia.state.value[key] = state[key];\n        }\n    }\n}\n\nfunction formatDisplay(display) {\n    return {\n        _custom: {\n            display,\n        },\n    };\n}\nconst PINIA_ROOT_LABEL = 'üçç Pinia (root)';\nconst PINIA_ROOT_ID = '_root';\nfunction formatStoreForInspectorTree(store) {\n    return isPinia(store)\n        ? {\n            id: PINIA_ROOT_ID,\n            label: PINIA_ROOT_LABEL,\n        }\n        : {\n            id: store.$id,\n            label: store.$id,\n        };\n}\nfunction formatStoreForInspectorState(store) {\n    if (isPinia(store)) {\n        const storeNames = Array.from(store._s.keys());\n        const storeMap = store._s;\n        const state = {\n            state: storeNames.map((storeId) => ({\n                editable: true,\n                key: storeId,\n                value: store.state.value[storeId],\n            })),\n            getters: storeNames\n                .filter((id) => storeMap.get(id)._getters)\n                .map((id) => {\n                const store = storeMap.get(id);\n                return {\n                    editable: false,\n                    key: id,\n                    value: store._getters.reduce((getters, key) => {\n                        getters[key] = store[key];\n                        return getters;\n                    }, {}),\n                };\n            }),\n        };\n        return state;\n    }\n    const state = {\n        state: Object.keys(store.$state).map((key) => ({\n            editable: true,\n            key,\n            value: store.$state[key],\n        })),\n    };\n    // avoid adding empty getters\n    if (store._getters && store._getters.length) {\n        state.getters = store._getters.map((getterName) => ({\n            editable: false,\n            key: getterName,\n            value: store[getterName],\n        }));\n    }\n    if (store._customProperties.size) {\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\n            editable: true,\n            key,\n            value: store[key],\n        }));\n    }\n    return state;\n}\nfunction formatEventData(events) {\n    if (!events)\n        return {};\n    if (Array.isArray(events)) {\n        // TODO: handle add and delete for arrays and objects\n        return events.reduce((data, event) => {\n            data.keys.push(event.key);\n            data.operations.push(event.type);\n            data.oldValue[event.key] = event.oldValue;\n            data.newValue[event.key] = event.newValue;\n            return data;\n        }, {\n            oldValue: {},\n            keys: [],\n            operations: [],\n            newValue: {},\n        });\n    }\n    else {\n        return {\n            operation: formatDisplay(events.type),\n            key: formatDisplay(events.key),\n            oldValue: events.oldValue,\n            newValue: events.newValue,\n        };\n    }\n}\nfunction formatMutationType(type) {\n    switch (type) {\n        case MutationType.direct:\n            return 'mutation';\n        case MutationType.patchFunction:\n            return '$patch';\n        case MutationType.patchObject:\n            return '$patch';\n        default:\n            return 'unknown';\n    }\n}\n\n// timeline can be paused when directly changing the state\nlet isTimelineActive = true;\nconst componentStateTypes = [];\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\nconst INSPECTOR_ID = 'pinia';\nconst { assign: assign$1 } = Object;\n/**\n * Gets the displayed name of a store in devtools\n *\n * @param id - id of the store\n * @returns a formatted string\n */\nconst getStoreType = (id) => 'üçç ' + id;\n/**\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\n * as soon as it is added to the application.\n *\n * @param app - Vue application\n * @param pinia - pinia instance\n */\nfunction registerPiniaDevtools(app, pinia) {\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia üçç',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n    }, (api) => {\n        if (typeof api.now !== 'function') {\n            toastMessage('You seem to be using an outdated version of Vue Devtools. Are you still using the Beta release instead of the stable one? You can find the links at https://devtools.vuejs.org/guide/installation.html.');\n        }\n        api.addTimelineLayer({\n            id: MUTATIONS_LAYER_ID,\n            label: `Pinia üçç`,\n            color: 0xe5df88,\n        });\n        api.addInspector({\n            id: INSPECTOR_ID,\n            label: 'Pinia üçç',\n            icon: 'storage',\n            treeFilterPlaceholder: 'Search stores',\n            actions: [\n                {\n                    icon: 'content_copy',\n                    action: () => {\n                        actionGlobalCopyState(pinia);\n                    },\n                    tooltip: 'Serialize and copy the state',\n                },\n                {\n                    icon: 'content_paste',\n                    action: async () => {\n                        await actionGlobalPasteState(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Replace the state with the content of your clipboard',\n                },\n                {\n                    icon: 'save',\n                    action: () => {\n                        actionGlobalSaveState(pinia);\n                    },\n                    tooltip: 'Save the state as a JSON file',\n                },\n                {\n                    icon: 'folder_open',\n                    action: async () => {\n                        await actionGlobalOpenStateFile(pinia);\n                        api.sendInspectorTree(INSPECTOR_ID);\n                        api.sendInspectorState(INSPECTOR_ID);\n                    },\n                    tooltip: 'Import the state from a JSON file',\n                },\n            ],\n            nodeActions: [\n                {\n                    icon: 'restore',\n                    tooltip: 'Reset the state (with \"$reset\")',\n                    action: (nodeId) => {\n                        const store = pinia._s.get(nodeId);\n                        if (!store) {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it wasn't found.`, 'warn');\n                        }\n                        else if (typeof store.$reset !== 'function') {\n                            toastMessage(`Cannot reset \"${nodeId}\" store because it doesn't have a \"$reset\" method implemented.`, 'warn');\n                        }\n                        else {\n                            store.$reset();\n                            toastMessage(`Store \"${nodeId}\" reset.`);\n                        }\n                    },\n                },\n            ],\n        });\n        api.on.inspectComponent((payload) => {\n            const proxy = (payload.componentInstance &&\n                payload.componentInstance.proxy);\n            if (proxy && proxy._pStores) {\n                const piniaStores = payload.componentInstance.proxy._pStores;\n                Object.values(piniaStores).forEach((store) => {\n                    payload.instanceData.state.push({\n                        type: getStoreType(store.$id),\n                        key: 'state',\n                        editable: true,\n                        value: store._isOptionsAPI\n                            ? {\n                                _custom: {\n                                    value: toRaw(store.$state),\n                                    actions: [\n                                        {\n                                            icon: 'restore',\n                                            tooltip: 'Reset the state of this store',\n                                            action: () => store.$reset(),\n                                        },\n                                    ],\n                                },\n                            }\n                            : // NOTE: workaround to unwrap transferred refs\n                                Object.keys(store.$state).reduce((state, key) => {\n                                    state[key] = store.$state[key];\n                                    return state;\n                                }, {}),\n                    });\n                    if (store._getters && store._getters.length) {\n                        payload.instanceData.state.push({\n                            type: getStoreType(store.$id),\n                            key: 'getters',\n                            editable: false,\n                            value: store._getters.reduce((getters, key) => {\n                                try {\n                                    getters[key] = store[key];\n                                }\n                                catch (error) {\n                                    // @ts-expect-error: we just want to show it in devtools\n                                    getters[key] = error;\n                                }\n                                return getters;\n                            }, {}),\n                        });\n                    }\n                });\n            }\n        });\n        api.on.getInspectorTree((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                let stores = [pinia];\n                stores = stores.concat(Array.from(pinia._s.values()));\n                payload.rootNodes = (payload.filter\n                    ? stores.filter((store) => '$id' in store\n                        ? store.$id\n                            .toLowerCase()\n                            .includes(payload.filter.toLowerCase())\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\n                    : stores).map(formatStoreForInspectorTree);\n            }\n        });\n        // Expose pinia instance as $pinia to window\n        globalThis.$pinia = pinia;\n        api.on.getInspectorState((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    // this could be the selected store restored for a different project\n                    // so it's better not to say anything here\n                    return;\n                }\n                if (inspectedStore) {\n                    // Expose selected store as $store to window\n                    if (payload.nodeId !== PINIA_ROOT_ID)\n                        globalThis.$store = toRaw(inspectedStore);\n                    payload.state = formatStoreForInspectorState(inspectedStore);\n                }\n            }\n        });\n        api.on.editInspectorState((payload) => {\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\n                    ? pinia\n                    : pinia._s.get(payload.nodeId);\n                if (!inspectedStore) {\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (!isPinia(inspectedStore)) {\n                    // access only the state\n                    if (path.length !== 1 ||\n                        !inspectedStore._customProperties.has(path[0]) ||\n                        path[0] in inspectedStore.$state) {\n                        path.unshift('$state');\n                    }\n                }\n                else {\n                    // Root access, we can omit the `.value` because the devtools API does it for us\n                    path.unshift('state');\n                }\n                isTimelineActive = false;\n                payload.set(inspectedStore, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n        api.on.editComponentState((payload) => {\n            if (payload.type.startsWith('üçç')) {\n                const storeId = payload.type.replace(/^üçç\\s*/, '');\n                const store = pinia._s.get(storeId);\n                if (!store) {\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\n                }\n                const { path } = payload;\n                if (path[0] !== 'state') {\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\n                }\n                // rewrite the first entry to be able to directly set the state as\n                // well as any other path\n                path[0] = '$state';\n                isTimelineActive = false;\n                payload.set(store, path, payload.state.value);\n                isTimelineActive = true;\n            }\n        });\n    });\n}\nfunction addStoreToDevtools(app, store) {\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\n        componentStateTypes.push(getStoreType(store.$id));\n    }\n    setupDevtoolsPlugin({\n        id: 'dev.esm.pinia',\n        label: 'Pinia üçç',\n        logo: 'https://pinia.vuejs.org/logo.svg',\n        packageName: 'pinia',\n        homepage: 'https://pinia.vuejs.org',\n        componentStateTypes,\n        app,\n        settings: {\n            logStoreChanges: {\n                label: 'Notify about new/deleted stores',\n                type: 'boolean',\n                defaultValue: true,\n            },\n            // useEmojis: {\n            //   label: 'Use emojis in messages ‚ö°Ô∏è',\n            //   type: 'boolean',\n            //   defaultValue: true,\n            // },\n        },\n    }, (api) => {\n        // gracefully handle errors\n        const now = typeof api.now === 'function' ? api.now.bind(api) : Date.now;\n        store.$onAction(({ after, onError, name, args }) => {\n            const groupId = runningActionId++;\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: 'üõ´ ' + name,\n                    subtitle: 'start',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        action: formatDisplay(name),\n                        args,\n                    },\n                    groupId,\n                },\n            });\n            after((result) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        title: 'üõ¨ ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            result,\n                        },\n                        groupId,\n                    },\n                });\n            });\n            onError((error) => {\n                activeAction = undefined;\n                api.addTimelineEvent({\n                    layerId: MUTATIONS_LAYER_ID,\n                    event: {\n                        time: now(),\n                        logType: 'error',\n                        title: 'üí• ' + name,\n                        subtitle: 'end',\n                        data: {\n                            store: formatDisplay(store.$id),\n                            action: formatDisplay(name),\n                            args,\n                            error,\n                        },\n                        groupId,\n                    },\n                });\n            });\n        }, true);\n        store._customProperties.forEach((name) => {\n            watch(() => unref(store[name]), (newValue, oldValue) => {\n                api.notifyComponentUpdate();\n                api.sendInspectorState(INSPECTOR_ID);\n                if (isTimelineActive) {\n                    api.addTimelineEvent({\n                        layerId: MUTATIONS_LAYER_ID,\n                        event: {\n                            time: now(),\n                            title: 'Change',\n                            subtitle: name,\n                            data: {\n                                newValue,\n                                oldValue,\n                            },\n                            groupId: activeAction,\n                        },\n                    });\n                }\n            }, { deep: true });\n        });\n        store.$subscribe(({ events, type }, state) => {\n            api.notifyComponentUpdate();\n            api.sendInspectorState(INSPECTOR_ID);\n            if (!isTimelineActive)\n                return;\n            // rootStore.state[store.id] = state\n            const eventData = {\n                time: now(),\n                title: formatMutationType(type),\n                data: assign$1({ store: formatDisplay(store.$id) }, formatEventData(events)),\n                groupId: activeAction,\n            };\n            if (type === MutationType.patchFunction) {\n                eventData.subtitle = '‚§µÔ∏è';\n            }\n            else if (type === MutationType.patchObject) {\n                eventData.subtitle = 'üß©';\n            }\n            else if (events && !Array.isArray(events)) {\n                eventData.subtitle = events.type;\n            }\n            if (events) {\n                eventData.data['rawEvent(s)'] = {\n                    _custom: {\n                        display: 'DebuggerEvent',\n                        type: 'object',\n                        tooltip: 'raw DebuggerEvent[]',\n                        value: events,\n                    },\n                };\n            }\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: eventData,\n            });\n        }, { detached: true, flush: 'sync' });\n        const hotUpdate = store._hotUpdate;\n        store._hotUpdate = markRaw((newStore) => {\n            hotUpdate(newStore);\n            api.addTimelineEvent({\n                layerId: MUTATIONS_LAYER_ID,\n                event: {\n                    time: now(),\n                    title: 'üî• ' + store.$id,\n                    subtitle: 'HMR update',\n                    data: {\n                        store: formatDisplay(store.$id),\n                        info: formatDisplay(`HMR update`),\n                    },\n                },\n            });\n            // update the devtools too\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n        });\n        const { $dispose } = store;\n        store.$dispose = () => {\n            $dispose();\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(INSPECTOR_ID);\n            api.sendInspectorState(INSPECTOR_ID);\n            api.getSettings().logStoreChanges &&\n                toastMessage(`Disposed \"${store.$id}\" store üóë`);\n        };\n        // trigger an update so it can display new registered stores\n        api.notifyComponentUpdate();\n        api.sendInspectorTree(INSPECTOR_ID);\n        api.sendInspectorState(INSPECTOR_ID);\n        api.getSettings().logStoreChanges &&\n            toastMessage(`\"${store.$id}\" store installed üÜï`);\n    });\n}\nlet runningActionId = 0;\nlet activeAction;\n/**\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the\n * context of all actions, allowing us to set `runningAction` on each access and effectively associating any state\n * mutation to the action.\n *\n * @param store - store to patch\n * @param actionNames - list of actionst to patch\n */\nfunction patchActionForGrouping(store, actionNames, wrapWithProxy) {\n    // original actions of the store as they are given by pinia. We are going to override them\n    const actions = actionNames.reduce((storeActions, actionName) => {\n        // use toRaw to avoid tracking #541\n        storeActions[actionName] = toRaw(store)[actionName];\n        return storeActions;\n    }, {});\n    for (const actionName in actions) {\n        store[actionName] = function () {\n            // the running action id is incremented in a before action hook\n            const _actionId = runningActionId;\n            const trackedStore = wrapWithProxy\n                ? new Proxy(store, {\n                    get(...args) {\n                        activeAction = _actionId;\n                        return Reflect.get(...args);\n                    },\n                    set(...args) {\n                        activeAction = _actionId;\n                        return Reflect.set(...args);\n                    },\n                })\n                : store;\n            // For Setup Stores we need https://github.com/tc39/proposal-async-context\n            activeAction = _actionId;\n            const retValue = actions[actionName].apply(trackedStore, arguments);\n            // this is safer as async actions in Setup Stores would associate mutations done outside of the action\n            activeAction = undefined;\n            return retValue;\n        };\n    }\n}\n/**\n * pinia.use(devtoolsPlugin)\n */\nfunction devtoolsPlugin({ app, store, options }) {\n    // HMR module\n    if (store.$id.startsWith('__hot:')) {\n        return;\n    }\n    // detect option api vs setup api\n    store._isOptionsAPI = !!options.state;\n    // Do not overwrite actions mocked by @pinia/testing (#2298)\n    if (!store._p._testing) {\n        patchActionForGrouping(store, Object.keys(options.actions), store._isOptionsAPI);\n        // Upgrade the HMR to also update the new actions\n        const originalHotUpdate = store._hotUpdate;\n        toRaw(store)._hotUpdate = function (newStore) {\n            originalHotUpdate.apply(this, arguments);\n            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions), !!store._isOptionsAPI);\n        };\n    }\n    addStoreToDevtools(app, \n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\n    store);\n}\n\n/**\n * Creates a Pinia instance to be used by the application\n */\nfunction createPinia() {\n    const scope = effectScope(true);\n    // NOTE: here we could check the window object for a state and directly set it\n    // if there is anything like it with Vue 3 SSR\n    const state = scope.run(() => ref({}));\n    let _p = [];\n    // plugins added before calling app.use(pinia)\n    let toBeInstalled = [];\n    const pinia = markRaw({\n        install(app) {\n            // this allows calling useStore() outside of a component setup after\n            // installing pinia's plugin\n            setActivePinia(pinia);\n            pinia._a = app;\n            app.provide(piniaSymbol, pinia);\n            app.config.globalProperties.$pinia = pinia;\n            /* istanbul ignore else */\n            if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n                registerPiniaDevtools(app, pinia);\n            }\n            toBeInstalled.forEach((plugin) => _p.push(plugin));\n            toBeInstalled = [];\n        },\n        use(plugin) {\n            if (!this._a) {\n                toBeInstalled.push(plugin);\n            }\n            else {\n                _p.push(plugin);\n            }\n            return this;\n        },\n        _p,\n        // it's actually undefined here\n        // @ts-expect-error\n        _a: null,\n        _e: scope,\n        _s: new Map(),\n        state,\n    });\n    // pinia devtools rely on dev only features so they cannot be forced unless\n    // the dev build of Vue is used. Avoid old browsers like IE11.\n    if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT && typeof Proxy !== 'undefined') {\n        pinia.use(devtoolsPlugin);\n    }\n    return pinia;\n}\n/**\n * Dispose a Pinia instance by stopping its effectScope and removing the state, plugins and stores. This is mostly\n * useful in tests, with both a testing pinia or a regular pinia and in applications that use multiple pinia instances.\n * Once disposed, the pinia instance cannot be used anymore.\n *\n * @param pinia - pinia instance\n */\nfunction disposePinia(pinia) {\n    pinia._e.stop();\n    pinia._s.clear();\n    pinia._p.splice(0);\n    pinia.state.value = {};\n    // @ts-expect-error: non valid\n    pinia._a = null;\n}\n\n/**\n * Checks if a function is a `StoreDefinition`.\n *\n * @param fn - object to test\n * @returns true if `fn` is a StoreDefinition\n */\nconst isUseStore = (fn) => {\n    return typeof fn === 'function' && typeof fn.$id === 'string';\n};\n/**\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\n * remove any key not existing in `newState` and recursively merge plain\n * objects.\n *\n * @param newState - new state object to be patched\n * @param oldState - old state that should be used to patch newState\n * @returns - newState\n */\nfunction patchObject(newState, oldState) {\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in oldState) {\n        const subPatch = oldState[key];\n        // skip the whole sub tree\n        if (!(key in newState)) {\n            continue;\n        }\n        const targetValue = newState[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            newState[key] = patchObject(targetValue, subPatch);\n        }\n        else {\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\n            // just set the whole thing\n            newState[key] = subPatch;\n        }\n    }\n    return newState;\n}\n/**\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\n *\n * @example\n * ```js\n * const useUser = defineStore(...)\n * if (import.meta.hot) {\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\n * }\n * ```\n *\n * @param initialUseStore - return of the defineStore to hot update\n * @param hot - `import.meta.hot`\n */\nfunction acceptHMRUpdate(initialUseStore, hot) {\n    // strip as much as possible from iife.prod\n    if (!(process.env.NODE_ENV !== 'production')) {\n        return () => { };\n    }\n    return (newModule) => {\n        const pinia = hot.data.pinia || initialUseStore._pinia;\n        if (!pinia) {\n            // this store is still not used\n            return;\n        }\n        // preserve the pinia instance across loads\n        hot.data.pinia = pinia;\n        // console.log('got data', newStore)\n        for (const exportName in newModule) {\n            const useStore = newModule[exportName];\n            // console.log('checking for', exportName)\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\n                // console.log('Accepting update for', useStore.$id)\n                const id = useStore.$id;\n                if (id !== initialUseStore.$id) {\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\n                    // return import.meta.hot.invalidate()\n                    return hot.invalidate();\n                }\n                const existingStore = pinia._s.get(id);\n                if (!existingStore) {\n                    console.log(`[Pinia]: skipping hmr because store doesn't exist yet`);\n                    return;\n                }\n                useStore(pinia, existingStore);\n            }\n        }\n    };\n}\n\nconst noop = () => { };\nfunction addSubscription(subscriptions, callback, detached, onCleanup = noop) {\n    subscriptions.push(callback);\n    const removeSubscription = () => {\n        const idx = subscriptions.indexOf(callback);\n        if (idx > -1) {\n            subscriptions.splice(idx, 1);\n            onCleanup();\n        }\n    };\n    if (!detached && getCurrentScope()) {\n        onScopeDispose(removeSubscription);\n    }\n    return removeSubscription;\n}\nfunction triggerSubscriptions(subscriptions, ...args) {\n    subscriptions.slice().forEach((callback) => {\n        callback(...args);\n    });\n}\n\nconst fallbackRunWithContext = (fn) => fn();\n/**\n * Marks a function as an action for `$onAction`\n * @internal\n */\nconst ACTION_MARKER = Symbol();\n/**\n * Action name symbol. Allows to add a name to an action after defining it\n * @internal\n */\nconst ACTION_NAME = Symbol();\nfunction mergeReactiveObjects(target, patchToApply) {\n    // Handle Map instances\n    if (target instanceof Map && patchToApply instanceof Map) {\n        patchToApply.forEach((value, key) => target.set(key, value));\n    }\n    else if (target instanceof Set && patchToApply instanceof Set) {\n        // Handle Set instances\n        patchToApply.forEach(target.add, target);\n    }\n    // no need to go through symbols because they cannot be serialized anyway\n    for (const key in patchToApply) {\n        if (!patchToApply.hasOwnProperty(key))\n            continue;\n        const subPatch = patchToApply[key];\n        const targetValue = target[key];\n        if (isPlainObject(targetValue) &&\n            isPlainObject(subPatch) &&\n            target.hasOwnProperty(key) &&\n            !isRef(subPatch) &&\n            !isReactive(subPatch)) {\n            // NOTE: here I wanted to warn about inconsistent types but it's not possible because in setup stores one might\n            // start the value of a property as a certain type e.g. a Map, and then for some reason, during SSR, change that\n            // to `undefined`. When trying to hydrate, we want to override the Map with `undefined`.\n            target[key] = mergeReactiveObjects(targetValue, subPatch);\n        }\n        else {\n            // @ts-expect-error: subPatch is a valid value\n            target[key] = subPatch;\n        }\n    }\n    return target;\n}\nconst skipHydrateSymbol = (process.env.NODE_ENV !== 'production')\n    ? Symbol('pinia:skipHydration')\n    : /* istanbul ignore next */ Symbol();\n/**\n * Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a\n * stateful object in the store but it isn't really state. e.g. returning a router instance in a setup store.\n *\n * @param obj - target object\n * @returns obj\n */\nfunction skipHydrate(obj) {\n    return Object.defineProperty(obj, skipHydrateSymbol, {});\n}\n/**\n * Returns whether a value should be hydrated\n *\n * @param obj - target variable\n * @returns true if `obj` should be hydrated\n */\nfunction shouldHydrate(obj) {\n    return (!isPlainObject(obj) ||\n        !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol));\n}\nconst { assign } = Object;\nfunction isComputed(o) {\n    return !!(isRef(o) && o.effect);\n}\nfunction createOptionsStore(id, options, pinia, hot) {\n    const { state, actions, getters } = options;\n    const initialState = pinia.state.value[id];\n    let store;\n    function setup() {\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n            /* istanbul ignore if */\n            pinia.state.value[id] = state ? state() : {};\n        }\n        // avoid creating a state in pinia.state.value\n        const localState = (process.env.NODE_ENV !== 'production') && hot\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\n                toRefs(ref(state ? state() : {}).value)\n            : toRefs(pinia.state.value[id]);\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\n            if ((process.env.NODE_ENV !== 'production') && name in localState) {\n                console.warn(`[üçç]: A getter cannot have the same name as another state property. Rename one of them. Found with \"${name}\" in store \"${id}\".`);\n            }\n            computedGetters[name] = markRaw(computed(() => {\n                setActivePinia(pinia);\n                // it was created just before\n                const store = pinia._s.get(id);\n                // allow cross using stores\n                // @ts-expect-error\n                // return getters![name].call(context, context)\n                // TODO: avoid reading the getter while assigning with a global variable\n                return getters[name].call(store, store);\n            }));\n            return computedGetters;\n        }, {}));\n    }\n    store = createSetupStore(id, setup, options, pinia, hot, true);\n    return store;\n}\nfunction createSetupStore($id, setup, options = {}, pinia, hot, isOptionsStore) {\n    let scope;\n    const optionsForPlugin = assign({ actions: {} }, options);\n    /* istanbul ignore if */\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\n        throw new Error('Pinia destroyed');\n    }\n    // watcher options for $subscribe\n    const $subscribeOptions = { deep: true };\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        $subscribeOptions.onTrigger = (event) => {\n            /* istanbul ignore else */\n            if (isListening) {\n                debuggerEvents = event;\n                // avoid triggering this while the store is being built and the state is being set in pinia\n            }\n            else if (isListening == false && !store._hotUpdating) {\n                // let patch send all the events together later\n                /* istanbul ignore else */\n                if (Array.isArray(debuggerEvents)) {\n                    debuggerEvents.push(event);\n                }\n                else {\n                    console.error('üçç debuggerEvents should be an array. This is most likely an internal Pinia bug.');\n                }\n            }\n        };\n    }\n    // internal state\n    let isListening; // set to true at the end\n    let isSyncListening; // set to true at the end\n    let subscriptions = [];\n    let actionSubscriptions = [];\n    let debuggerEvents;\n    const initialState = pinia.state.value[$id];\n    // avoid setting the state for option stores if it is set\n    // by the setup\n    if (!isOptionsStore && !initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\n        /* istanbul ignore if */\n        pinia.state.value[$id] = {};\n    }\n    const hotState = ref({});\n    // avoid triggering too many listeners\n    // https://github.com/vuejs/pinia/issues/1129\n    let activeListener;\n    function $patch(partialStateOrMutator) {\n        let subscriptionMutation;\n        isListening = isSyncListening = false;\n        // reset the debugger events since patches are sync\n        /* istanbul ignore else */\n        if ((process.env.NODE_ENV !== 'production')) {\n            debuggerEvents = [];\n        }\n        if (typeof partialStateOrMutator === 'function') {\n            partialStateOrMutator(pinia.state.value[$id]);\n            subscriptionMutation = {\n                type: MutationType.patchFunction,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        else {\n            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);\n            subscriptionMutation = {\n                type: MutationType.patchObject,\n                payload: partialStateOrMutator,\n                storeId: $id,\n                events: debuggerEvents,\n            };\n        }\n        const myListenerId = (activeListener = Symbol());\n        nextTick().then(() => {\n            if (activeListener === myListenerId) {\n                isListening = true;\n            }\n        });\n        isSyncListening = true;\n        // because we paused the watcher, we need to manually call the subscriptions\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\n    }\n    const $reset = isOptionsStore\n        ? function $reset() {\n            const { state } = options;\n            const newState = state ? state() : {};\n            // we use a patch to group all changes into one single subscription\n            this.$patch(($state) => {\n                // @ts-expect-error: FIXME: shouldn't error?\n                assign($state, newState);\n            });\n        }\n        : /* istanbul ignore next */\n            (process.env.NODE_ENV !== 'production')\n                ? () => {\n                    throw new Error(`üçç: Store \"${$id}\" is built using the setup syntax and does not implement $reset().`);\n                }\n                : noop;\n    function $dispose() {\n        scope.stop();\n        subscriptions = [];\n        actionSubscriptions = [];\n        pinia._s.delete($id);\n    }\n    /**\n     * Helper that wraps function so it can be tracked with $onAction\n     * @param fn - action to wrap\n     * @param name - name of the action\n     */\n    const action = (fn, name = '') => {\n        if (ACTION_MARKER in fn) {\n            fn[ACTION_NAME] = name;\n            return fn;\n        }\n        const wrappedAction = function () {\n            setActivePinia(pinia);\n            const args = Array.from(arguments);\n            const afterCallbackList = [];\n            const onErrorCallbackList = [];\n            function after(callback) {\n                afterCallbackList.push(callback);\n            }\n            function onError(callback) {\n                onErrorCallbackList.push(callback);\n            }\n            // @ts-expect-error\n            triggerSubscriptions(actionSubscriptions, {\n                args,\n                name: wrappedAction[ACTION_NAME],\n                store,\n                after,\n                onError,\n            });\n            let ret;\n            try {\n                ret = fn.apply(this && this.$id === $id ? this : store, args);\n                // handle sync errors\n            }\n            catch (error) {\n                triggerSubscriptions(onErrorCallbackList, error);\n                throw error;\n            }\n            if (ret instanceof Promise) {\n                return ret\n                    .then((value) => {\n                    triggerSubscriptions(afterCallbackList, value);\n                    return value;\n                })\n                    .catch((error) => {\n                    triggerSubscriptions(onErrorCallbackList, error);\n                    return Promise.reject(error);\n                });\n            }\n            // trigger after callbacks\n            triggerSubscriptions(afterCallbackList, ret);\n            return ret;\n        };\n        wrappedAction[ACTION_MARKER] = true;\n        wrappedAction[ACTION_NAME] = name; // will be set later\n        // @ts-expect-error: we are intentionally limiting the returned type to just Fn\n        // because all the added properties are internals that are exposed through `$onAction()` only\n        return wrappedAction;\n    };\n    const _hmrPayload = /*#__PURE__*/ markRaw({\n        actions: {},\n        getters: {},\n        state: [],\n        hotState,\n    });\n    const partialStore = {\n        _p: pinia,\n        // _s: scope,\n        $id,\n        $onAction: addSubscription.bind(null, actionSubscriptions),\n        $patch,\n        $reset,\n        $subscribe(callback, options = {}) {\n            const removeSubscription = addSubscription(subscriptions, callback, options.detached, () => stopWatcher());\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state) => {\n                if (options.flush === 'sync' ? isSyncListening : isListening) {\n                    callback({\n                        storeId: $id,\n                        type: MutationType.direct,\n                        events: debuggerEvents,\n                    }, state);\n                }\n            }, assign({}, $subscribeOptions, options)));\n            return removeSubscription;\n        },\n        $dispose,\n    };\n    const store = reactive((process.env.NODE_ENV !== 'production') || ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT)\n        ? assign({\n            _hmrPayload,\n            _customProperties: markRaw(new Set()), // devtools custom properties\n        }, partialStore\n        // must be added later\n        // setupStore\n        )\n        : partialStore);\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\n    // creating infinite loops.\n    pinia._s.set($id, store);\n    const runWithContext = (pinia._a && pinia._a.runWithContext) || fallbackRunWithContext;\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\n    const setupStore = runWithContext(() => pinia._e.run(() => (scope = effectScope()).run(() => setup({ action }))));\n    // overwrite existing actions to support $onAction\n    for (const key in setupStore) {\n        const prop = setupStore[key];\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\n            // mark it as a piece of state to be serialized\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                hotState.value[key] = toRef(setupStore, key);\n                // createOptionStore directly sets the state in pinia.state.value so we\n                // can just skip that\n            }\n            else if (!isOptionsStore) {\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\n                if (initialState && shouldHydrate(prop)) {\n                    if (isRef(prop)) {\n                        prop.value = initialState[key];\n                    }\n                    else {\n                        // probably a reactive object, lets recursively assign\n                        // @ts-expect-error: prop is unknown\n                        mergeReactiveObjects(prop, initialState[key]);\n                    }\n                }\n                // transfer the ref to the pinia state to keep everything in sync\n                pinia.state.value[$id][key] = prop;\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.state.push(key);\n            }\n            // action\n        }\n        else if (typeof prop === 'function') {\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : action(prop, key);\n            // this a hot module replacement store because the hotUpdate method needs\n            // to do it with the right context\n            // @ts-expect-error\n            setupStore[key] = actionValue;\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                _hmrPayload.actions[key] = prop;\n            }\n            // list actions so they can be used in plugins\n            // @ts-expect-error\n            optionsForPlugin.actions[key] = prop;\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            // add getters for devtools\n            if (isComputed(prop)) {\n                _hmrPayload.getters[key] = isOptionsStore\n                    ? // @ts-expect-error\n                        options.getters[key]\n                    : prop;\n                if (IS_CLIENT) {\n                    const getters = setupStore._getters ||\n                        // @ts-expect-error: same\n                        (setupStore._getters = markRaw([]));\n                    getters.push(key);\n                }\n            }\n        }\n    }\n    // add the state, getters, and action properties\n    /* istanbul ignore if */\n    assign(store, setupStore);\n    // allows retrieving reactive objects with `storeToRefs()`. Must be called after assigning to the reactive object.\n    // Make `storeToRefs()` work with `reactive()` #799\n    assign(toRaw(store), setupStore);\n    // use this instead of a computed with setter to be able to create it anywhere\n    // without linking the computed lifespan to wherever the store is first\n    // created.\n    Object.defineProperty(store, '$state', {\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\n        set: (state) => {\n            /* istanbul ignore if */\n            if ((process.env.NODE_ENV !== 'production') && hot) {\n                throw new Error('cannot set hotState');\n            }\n            $patch(($state) => {\n                // @ts-expect-error: FIXME: shouldn't error?\n                assign($state, state);\n            });\n        },\n    });\n    // add the hotUpdate before plugins to allow them to override it\n    /* istanbul ignore else */\n    if ((process.env.NODE_ENV !== 'production')) {\n        store._hotUpdate = markRaw((newStore) => {\n            store._hotUpdating = true;\n            newStore._hmrPayload.state.forEach((stateKey) => {\n                if (stateKey in store.$state) {\n                    const newStateTarget = newStore.$state[stateKey];\n                    const oldStateSource = store.$state[stateKey];\n                    if (typeof newStateTarget === 'object' &&\n                        isPlainObject(newStateTarget) &&\n                        isPlainObject(oldStateSource)) {\n                        patchObject(newStateTarget, oldStateSource);\n                    }\n                    else {\n                        // transfer the ref\n                        newStore.$state[stateKey] = oldStateSource;\n                    }\n                }\n                // patch direct access properties to allow store.stateProperty to work as\n                // store.$state.stateProperty\n                // @ts-expect-error: any type\n                store[stateKey] = toRef(newStore.$state, stateKey);\n            });\n            // remove deleted state properties\n            Object.keys(store.$state).forEach((stateKey) => {\n                if (!(stateKey in newStore.$state)) {\n                    // @ts-expect-error: noop if doesn't exist\n                    delete store[stateKey];\n                }\n            });\n            // avoid devtools logging this as a mutation\n            isListening = false;\n            isSyncListening = false;\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\n            isSyncListening = true;\n            nextTick().then(() => {\n                isListening = true;\n            });\n            for (const actionName in newStore._hmrPayload.actions) {\n                const actionFn = newStore[actionName];\n                // @ts-expect-error: actionName is a string\n                store[actionName] =\n                    //\n                    action(actionFn, actionName);\n            }\n            // TODO: does this work in both setup and option store?\n            for (const getterName in newStore._hmrPayload.getters) {\n                const getter = newStore._hmrPayload.getters[getterName];\n                const getterValue = isOptionsStore\n                    ? // special handling of options api\n                        computed(() => {\n                            setActivePinia(pinia);\n                            return getter.call(store, store);\n                        })\n                    : getter;\n                // @ts-expect-error: getterName is a string\n                store[getterName] =\n                    //\n                    getterValue;\n            }\n            // remove deleted getters\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\n                if (!(key in newStore._hmrPayload.getters)) {\n                    // @ts-expect-error: noop if doesn't exist\n                    delete store[key];\n                }\n            });\n            // remove old actions\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\n                if (!(key in newStore._hmrPayload.actions)) {\n                    // @ts-expect-error: noop if doesn't exist\n                    delete store[key];\n                }\n            });\n            // update the values used in devtools and to allow deleting new properties later on\n            store._hmrPayload = newStore._hmrPayload;\n            store._getters = newStore._getters;\n            store._hotUpdating = false;\n        });\n    }\n    if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n        const nonEnumerable = {\n            writable: true,\n            configurable: true,\n            // avoid warning on devtools trying to display this property\n            enumerable: false,\n        };\n        ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\n            Object.defineProperty(store, p, assign({ value: store[p] }, nonEnumerable));\n        });\n    }\n    // apply all plugins\n    pinia._p.forEach((extender) => {\n        /* istanbul ignore else */\n        if ((((process.env.NODE_ENV !== 'production') || (typeof __VUE_PROD_DEVTOOLS__ !== 'undefined' && __VUE_PROD_DEVTOOLS__)) && !(process.env.NODE_ENV === 'test')) && IS_CLIENT) {\n            const extensions = scope.run(() => extender({\n                store: store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            }));\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\n            assign(store, extensions);\n        }\n        else {\n            assign(store, scope.run(() => extender({\n                store: store,\n                app: pinia._a,\n                pinia,\n                options: optionsForPlugin,\n            })));\n        }\n    });\n    if ((process.env.NODE_ENV !== 'production') &&\n        store.$state &&\n        typeof store.$state === 'object' &&\n        typeof store.$state.constructor === 'function' &&\n        !store.$state.constructor.toString().includes('[native code]')) {\n        console.warn(`[üçç]: The \"state\" must be a plain object. It cannot be\\n` +\n            `\\tstate: () => new MyClass()\\n` +\n            `Found in store \"${store.$id}\".`);\n    }\n    // only apply hydrate to option stores with an initial state in pinia\n    if (initialState &&\n        isOptionsStore &&\n        options.hydrate) {\n        options.hydrate(store.$state, initialState);\n    }\n    isListening = true;\n    isSyncListening = true;\n    return store;\n}\n// allows unused stores to be tree shaken\n/*! #__NO_SIDE_EFFECTS__ */\nfunction defineStore(\n// TODO: add proper types from above\nid, setup, setupOptions) {\n    let options;\n    const isSetupStore = typeof setup === 'function';\n    // the option store setup will contain the actual options in this case\n    options = isSetupStore ? setupOptions : setup;\n    function useStore(pinia, hot) {\n        const hasContext = hasInjectionContext();\n        pinia =\n            // in test mode, ignore the argument provided as we can always retrieve a\n            // pinia instance with getActivePinia()\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\n                (hasContext ? inject(piniaSymbol, null) : null);\n        if (pinia)\n            setActivePinia(pinia);\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\n            throw new Error(`[üçç]: \"getActivePinia()\" was called but there was no active Pinia. Are you trying to use a store before calling \"app.use(pinia)\"?\\n` +\n                `See https://pinia.vuejs.org/core-concepts/outside-component-usage.html for help.\\n` +\n                `This will fail in production.`);\n        }\n        pinia = activePinia;\n        if (!pinia._s.has(id)) {\n            // creating the store registers it in `pinia._s`\n            if (isSetupStore) {\n                createSetupStore(id, setup, options, pinia);\n            }\n            else {\n                createOptionsStore(id, options, pinia);\n            }\n            /* istanbul ignore else */\n            if ((process.env.NODE_ENV !== 'production')) {\n                // @ts-expect-error: not the right inferred type\n                useStore._pinia = pinia;\n            }\n        }\n        const store = pinia._s.get(id);\n        if ((process.env.NODE_ENV !== 'production') && hot) {\n            const hotId = '__hot:' + id;\n            const newStore = isSetupStore\n                ? createSetupStore(hotId, setup, options, pinia, true)\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\n            hot._hotUpdate(newStore);\n            // cleanup the state properties and the store from the cache\n            delete pinia.state.value[hotId];\n            pinia._s.delete(hotId);\n        }\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\n            const currentInstance = getCurrentInstance();\n            // save stores in instances to access them devtools\n            if (currentInstance &&\n                currentInstance.proxy &&\n                // avoid adding stores that are just built for hot module replacement\n                !hot) {\n                const vm = currentInstance.proxy;\n                const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\n                cache[id] = store;\n            }\n        }\n        // StoreGeneric cannot be casted towards Store\n        return store;\n    }\n    useStore.$id = id;\n    return useStore;\n}\n\nlet mapStoreSuffix = 'Store';\n/**\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\n * interface if you are using TypeScript.\n *\n * @param suffix - new suffix\n */\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\n) {\n    mapStoreSuffix = suffix;\n}\n/**\n * Allows using stores without the composition API (`setup()`) by generating an\n * object to be spread in the `computed` field of a component. It accepts a list\n * of store definitions.\n *\n * @example\n * ```js\n * export default {\n *   computed: {\n *     // other computed properties\n *     ...mapStores(useUserStore, useCartStore)\n *   },\n *\n *   created() {\n *     this.userStore // store with id \"user\"\n *     this.cartStore // store with id \"cart\"\n *   }\n * }\n * ```\n *\n * @param stores - list of stores to map to an object\n */\nfunction mapStores(...stores) {\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\n        console.warn(`[üçç]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\n            `Replace\\n` +\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\n            `with\\n` +\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\n            `This will fail in production if not fixed.`);\n        stores = stores[0];\n    }\n    return stores.reduce((reduced, useStore) => {\n        // @ts-expect-error: $id is added by defineStore\n        reduced[useStore.$id + mapStoreSuffix] = function () {\n            return useStore(this.$pinia);\n        };\n        return reduced;\n    }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            reduced[key] = function () {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[key];\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function () {\n                const store = useStore(this.$pinia);\n                const storeKey = keysOrMapper[key];\n                // for some reason TS is unable to infer the type of storeKey to be a\n                // function\n                return typeof storeKey === 'function'\n                    ? storeKey.call(this, store)\n                    : // @ts-expect-error: FIXME: should work?\n                        store[storeKey];\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Alias for `mapState()`. You should use `mapState()` instead.\n * @deprecated use `mapState()` instead.\n */\nconst mapGetters = mapState;\n/**\n * Allows directly using actions from your store without using the composition\n * API (`setup()`) by generating an object to be spread in the `methods` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapActions(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[key](...args);\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            // @ts-expect-error\n            reduced[key] = function (...args) {\n                // @ts-expect-error: FIXME: should work?\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\n            };\n            return reduced;\n        }, {});\n}\n/**\n * Allows using state and getters from one store without using the composition\n * API (`setup()`) by generating an object to be spread in the `computed` field\n * of a component.\n *\n * @param useStore - store to map from\n * @param keysOrMapper - array or object\n */\nfunction mapWritableState(useStore, keysOrMapper) {\n    return Array.isArray(keysOrMapper)\n        ? keysOrMapper.reduce((reduced, key) => {\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[key];\n                },\n                set(value) {\n                    return (useStore(this.$pinia)[key] = value);\n                },\n            };\n            return reduced;\n        }, {})\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\n            reduced[key] = {\n                get() {\n                    return useStore(this.$pinia)[keysOrMapper[key]];\n                },\n                set(value) {\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\n                },\n            };\n            return reduced;\n        }, {});\n}\n\n/**\n * Creates an object of references with all the state, getters, and plugin-added\n * state properties of the store. Similar to `toRefs()` but specifically\n * designed for Pinia stores so methods and non reactive properties are\n * completely ignored.\n *\n * @param store - store to extract the refs from\n */\nfunction storeToRefs(store) {\n    const rawStore = toRaw(store);\n    const refs = {};\n    for (const key in rawStore) {\n        const value = rawStore[key];\n        // There is no native method to check for a computed\n        // https://github.com/vuejs/core/pull/4165\n        if (value.effect) {\n            // @ts-expect-error: too hard to type correctly\n            refs[key] =\n                // ...\n                computed({\n                    get: () => store[key],\n                    set(value) {\n                        store[key] = value;\n                    },\n                });\n        }\n        else if (isRef(value) || isReactive(value)) {\n            // @ts-expect-error: the key is state or getter\n            refs[key] =\n                // ---\n                toRef(store, key);\n        }\n    }\n    return refs;\n}\n\nexport { MutationType, acceptHMRUpdate, createPinia, defineStore, disposePinia, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, shouldHydrate, skipHydrate, storeToRefs };\n","/*!\n * SPDX-FileCopyrightText: 2025 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { getLoggerBuilder } from '@nextcloud/logger'\n\nexport const logger = getLoggerBuilder()\n\t.detectLogLevel()\n\t.setApp('twofactor_backupcodes')\n\t.build()\n","/*!\n * SPDX-FileCopyrightText: 2016 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { getCapabilities } from '@nextcloud/capabilities'\nimport { showError } from '@nextcloud/dialogs'\nimport { t } from '@nextcloud/l10n'\n\n/**\n * Open a new tab and print the given backup codes\n *\n * @param data - The backup codes to print\n */\nexport function print(data: string[]): void {\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tconst name = (getCapabilities() as any).theming.name || 'Nextcloud'\n\tconst newTab = window.open('', t('twofactor_backupcodes', '{name} backup codes', { name }))\n\tif (!newTab) {\n\t\tshowError(t('twofactor_backupcodes', 'Unable to open a new tab for printing'))\n\t\tthrow new Error('Unable to open a new tab for printing')\n\t}\n\n\tconst heading = newTab.document.createElement('h1')\n\theading.textContent = t('twofactor_backupcodes', '{name} backup codes', { name })\n\tconst pre = newTab.document.createElement('pre')\n\tfor (const code of data) {\n\t\tconst codeLine = newTab.document.createTextNode(code)\n\t\tpre.appendChild(codeLine)\n\t\tpre.appendChild(newTab.document.createElement('br'))\n\t}\n\n\tnewTab.document.body.innerHTML = ''\n\tnewTab.document.body.appendChild(heading)\n\tnewTab.document.body.appendChild(pre)\n\n\tnewTab.print()\n\tnewTab.close()\n}\n","/**\n * SPDX-FileCopyrightText: 2016 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport axios from '@nextcloud/axios'\nimport { generateUrl } from '@nextcloud/router'\n\nexport interface ITwoFactorBackupCodesState {\n\tenabled: boolean\n\ttotal: number\n\tused: number\n}\n\nexport interface IApiResponse {\n\tcodes: string[]\n\tstate: ITwoFactorBackupCodesState\n}\n\n/**\n * Generate new backup codes\n */\nexport async function generateCodes(): Promise<IApiResponse> {\n\tconst url = generateUrl('/apps/twofactor_backupcodes/settings/create')\n\n\tconst { data } = await axios.post<IApiResponse>(url)\n\treturn data\n}\n","/**\n * SPDX-FileCopyrightText: 2019 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport type { ITwoFactorBackupCodesState } from '../service/BackupCodesService.ts'\n\nimport { loadState } from '@nextcloud/initial-state'\nimport { defineStore } from 'pinia'\nimport { ref } from 'vue'\nimport { generateCodes } from '../service/BackupCodesService.ts'\n\nconst initialState = loadState<ITwoFactorBackupCodesState>('twofactor_backupcodes', 'state')\n\nexport const useStore = defineStore('twofactor_backupcodes', () => {\n\tconst enabled = ref(initialState.enabled)\n\tconst total = ref(initialState.total)\n\tconst used = ref(initialState.used)\n\tconst codes = ref<string[]>([])\n\n\t/**\n\t * Generate new backup codes and update the store state\n\t */\n\tasync function generate(): Promise<void> {\n\t\tenabled.value = false\n\n\t\tconst { codes: newCodes, state } = await generateCodes()\n\t\tenabled.value = state.enabled\n\t\ttotal.value = state.total\n\t\tused.value = state.used\n\t\tcodes.value = newCodes\n\t}\n\n\treturn {\n\t\tenabled,\n\t\ttotal,\n\t\tused,\n\t\tcodes,\n\n\t\tgenerate,\n\t}\n})\n","<!--\n  - SPDX-FileCopyrightText: 2018 Nextcloud GmbH and Nextcloud contributors\n  - SPDX-License-Identifier: AGPL-3.0-or-later\n-->\n\n<script setup lang=\"ts\">\nimport { getCapabilities } from '@nextcloud/capabilities'\nimport { showError } from '@nextcloud/dialogs'\nimport { t } from '@nextcloud/l10n'\nimport { confirmPassword } from '@nextcloud/password-confirmation'\nimport { computed, ref } from 'vue'\nimport NcButton from '@nextcloud/vue/components/NcButton'\nimport NcLoadingIcon from '@nextcloud/vue/components/NcLoadingIcon'\nimport { logger } from '../service/logger.ts'\nimport { print } from '../service/PrintService.js'\nimport { useStore } from '../store/index.ts'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst instanceName = (getCapabilities() as any).theming.name ?? 'Nextcloud'\n\nconst store = useStore()\nconst generatingCodes = ref(false)\n\nconst hasCodes = computed(() => {\n\treturn store.codes && store.codes.length > 0\n})\n\nconst downloadFilename = instanceName + '-backup-codes.txt'\nconst downloadUrl = computed(() => {\n\tif (!hasCodes.value) {\n\t\treturn ''\n\t}\n\treturn 'data:text/plain,' + encodeURIComponent(store.codes.reduce((prev, code) => {\n\t\treturn prev + code + '\\n'\n\t}, ''))\n})\n\n/**\n * Generate new backup codes\n */\nasync function generateBackupCodes() {\n\tawait confirmPassword()\n\t// Hide old codes\n\tgeneratingCodes.value = true\n\n\ttry {\n\t\tawait store.generate()\n\t} catch (error) {\n\t\tlogger.error('Error generating backup codes', { error })\n\t\tshowError(t('twofactor_backupcodes', 'An error occurred while generating your backup codes'))\n\t} finally {\n\t\tgeneratingCodes.value = false\n\t}\n}\n\n/**\n * Print the backup codes\n */\nfunction printCodes() {\n\tprint(!store.codes || store.codes.length === 0 ? [] : store.codes)\n}\n</script>\n\n<template>\n\t<div :class=\"$style.backupcodesSettings\">\n\t\t<NcButton\n\t\t\tv-if=\"!store.enabled\"\n\t\t\t:disabled=\"generatingCodes\"\n\t\t\tvariant=\"primary\"\n\t\t\t@click=\"generateBackupCodes\">\n\t\t\t<template #icon>\n\t\t\t\t<NcLoadingIcon v-if=\"generatingCodes\" />\n\t\t\t</template>\n\t\t\t{{ t('twofactor_backupcodes', 'Generate backup codes') }}\n\t\t</NcButton>\n\t\t<template v-else>\n\t\t\t<p>\n\t\t\t\t<template v-if=\"!hasCodes\">\n\t\t\t\t\t{{ t('twofactor_backupcodes', 'Backup codes have been generated. {used} of {total} codes have been used.', { used: store.used, total: store.total }) }}\n\t\t\t\t</template>\n\t\t\t\t<template v-else>\n\t\t\t\t\t{{ t('twofactor_backupcodes', 'These are your backup codes. Please save and/or print them as you will not be able to read the codes again later.') }}\n\t\t\t\t\t<ul :aria-label=\"t('twofactor_backupcodes', 'List of backup codes')\">\n\t\t\t\t\t\t<li\n\t\t\t\t\t\t\tv-for=\"code in store.codes\"\n\t\t\t\t\t\t\t:key=\"code\"\n\t\t\t\t\t\t\t:class=\"$style.backupcodesSettings__code\">\n\t\t\t\t\t\t\t{{ code }}\n\t\t\t\t\t\t</li>\n\t\t\t\t\t</ul>\n\t\t\t\t</template>\n\t\t\t</p>\n\t\t\t<p :class=\"$style.backupcodesSettings__actions\">\n\t\t\t\t<NcButton\n\t\t\t\t\tid=\"generate-backup-codes\"\n\t\t\t\t\tvariant=\"error\"\n\t\t\t\t\t@click=\"generateBackupCodes\">\n\t\t\t\t\t{{ t('twofactor_backupcodes', 'Regenerate backup codes') }}\n\t\t\t\t</NcButton>\n\t\t\t\t<template v-if=\"hasCodes\">\n\t\t\t\t\t<NcButton @click=\"printCodes\">\n\t\t\t\t\t\t{{ t('twofactor_backupcodes', 'Print backup codes') }}\n\t\t\t\t\t</NcButton>\n\t\t\t\t\t<NcButton\n\t\t\t\t\t\t:href=\"downloadUrl\"\n\t\t\t\t\t\t:download=\"downloadFilename\"\n\t\t\t\t\t\tvariant=\"primary\">\n\t\t\t\t\t\t{{ t('twofactor_backupcodes', 'Save backup codes') }}\n\t\t\t\t\t</NcButton>\n\t\t\t\t</template>\n\t\t\t</p>\n\t\t\t<p>\n\t\t\t\t<em>\n\t\t\t\t\t{{ t('twofactor_backupcodes', 'If you regenerate backup codes, you automatically invalidate old codes.') }}\n\t\t\t\t</em>\n\t\t\t</p>\n\t\t</template>\n\t</div>\n</template>\n\n<style module>\n.backupcodesSettings {\n\tdisplay: flex;\n\tflex-direction: column;\n}\n\n.backupcodesSettings__code {\n\tfont-family: monospace;\n\tletter-spacing: 0.02em;\n\tfont-size: 1.2em;\n}\n\n.backupcodesSettings__actions {\n\tdisplay: flex;\n\tflex-wrap: wrap;\n\tgap: var(--default-grid-baseline);\n}\n</style>\n","/**\n * SPDX-FileCopyrightText: 2016 Nextcloud GmbH and Nextcloud contributors\n * SPDX-License-Identifier: AGPL-3.0-or-later\n */\n\nimport { createPinia } from 'pinia'\nimport { createApp } from 'vue'\nimport PersonalSettings from './views/PersonalSettings.vue'\n\nconst pinia = createPinia()\nconst app = createApp(PersonalSettings)\napp.use(pinia)\napp.mount('#twofactor-backupcodes-settings')\n"],"names":["activePinia","setActivePinia","pinia","piniaSymbol","isPlainObject","o","MutationType","createPinia","scope","effectScope","state","ref","_p","toBeInstalled","markRaw","app","plugin","noop","addSubscription","subscriptions","callback","detached","onCleanup","removeSubscription","idx","getCurrentScope","onScopeDispose","triggerSubscriptions","args","fallbackRunWithContext","fn","ACTION_MARKER","ACTION_NAME","mergeReactiveObjects","target","patchToApply","value","key","subPatch","targetValue","isRef","isReactive","skipHydrateSymbol","shouldHydrate","obj","assign","isComputed","createOptionsStore","id","options","hot","actions","getters","initialState","store","setup","localState","toRefs","computedGetters","name","computed","createSetupStore","$id","isOptionsStore","optionsForPlugin","$subscribeOptions","isListening","isSyncListening","actionSubscriptions","debuggerEvents","activeListener","$patch","partialStateOrMutator","subscriptionMutation","myListenerId","nextTick","$reset","newState","$state","$dispose","action","wrappedAction","afterCallbackList","onErrorCallbackList","after","onError","ret","error","partialStore","stopWatcher","watch","reactive","setupStore","prop","actionValue","toRaw","extender","defineStore","setupOptions","isSetupStore","useStore","hasContext","hasInjectionContext","inject","logger","getLoggerBuilder","print","data","getCapabilities","newTab","t","showError","heading","pre","code","codeLine","generateCodes","url","generateUrl","axios","loadState","enabled","total","used","codes","generate","newCodes","instanceName","generatingCodes","hasCodes","downloadFilename","downloadUrl","prev","generateBackupCodes","confirmPassword","printCodes","_createElementBlock","_normalizeClass","$style","_unref","_Fragment","_createElementVNode","_createTextVNode","_toDisplayString","_openBlock","_renderList","_createVNode","NcButton","_createBlock","NcLoadingIcon","createApp","PersonalSettings"],"mappings":"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","x_google_ignoreList":[0]}